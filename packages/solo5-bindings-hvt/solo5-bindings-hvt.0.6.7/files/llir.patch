diff --git a/bindings/cpu_vectors_x86_64.S b/bindings/cpu_vectors_x86_64.S
index 2914c54..8f72f19 100644
--- a/bindings/cpu_vectors_x86_64.S
+++ b/bindings/cpu_vectors_x86_64.S
@@ -18,6 +18,10 @@
  * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
  */
 
+#ifdef __llir__
+
+#else
+
 .macro PUSH_CALLER_SAVE
     pushq %rax
     pushq %rdi
@@ -120,3 +124,5 @@ IRQ_ENTRY 12
 IRQ_ENTRY 13
 IRQ_ENTRY 14
 IRQ_ENTRY 15
+
+#endif
diff --git a/bindings/cpu_x86_64.c b/bindings/cpu_x86_64.c
index 44e667c..9f62f52 100644
--- a/bindings/cpu_x86_64.c
+++ b/bindings/cpu_x86_64.c
@@ -32,6 +32,9 @@ static uint64_t cpu_gdt64[GDT_NUM_ENTRIES] ALIGN_64_BIT;
  */
 static void gdt_init(void)
 {
+#ifdef __llir__
+    __builtin_trap();
+#else
     memset(cpu_gdt64, 0, sizeof(cpu_gdt64));
     cpu_gdt64[GDT_DESC_CODE] = GDT_DESC_CODE_VAL;
     cpu_gdt64[GDT_DESC_DATA] = GDT_DESC_DATA_VAL;
@@ -54,6 +57,7 @@ static void gdt_init(void)
               "n" (GDT_DESC_OFFSET(GDT_DESC_CODE)),
               "n" (GDT_DESC_OFFSET(GDT_DESC_DATA))
             : "%rax");
+#endif
 }
 
 static struct idt_gate_desc cpu_idt[IDT_NUM_ENTRIES] ALIGN_64_BIT;
@@ -127,7 +131,11 @@ static void idt_init(void)
     volatile struct idtptr idtptr;
     idtptr.limit = sizeof(cpu_idt) - 1;
     idtptr.base = (uint64_t) &cpu_idt;
+#ifdef __llir__
+    __builtin_trap();
+#else
     __asm__ __volatile__("lidt (%0)" :: "r" (&idtptr));
+#endif
 }
 
 static struct tss cpu_tss;
@@ -186,20 +194,32 @@ int cpu_intr_depth = 1;
 
 void cpu_intr_disable(void)
 {
+#ifdef __llir__
+    __builtin_trap();
+#else
     __asm__ __volatile__("cli");
+#endif
     cpu_intr_depth++;
 }
 
 void cpu_intr_enable(void)
 {
+#ifdef __llir__
+    __builtin_trap();
+#else
     assert(cpu_intr_depth > 0);
 
     if (--cpu_intr_depth == 0)
         __asm__ __volatile__("sti");
+#endif
 }
 
 void cpu_halt(void)
 {
+#ifdef __llir__
+    __builtin_trap();
+#else
     __asm__ __volatile__("cli; hlt");
     for(;;);
+#endif
 }
diff --git a/bindings/cpu_x86_64.h b/bindings/cpu_x86_64.h
index ceb5189..e38e05f 100644
--- a/bindings/cpu_x86_64.h
+++ b/bindings/cpu_x86_64.h
@@ -171,14 +171,21 @@ struct trap_regs {
 
 static inline uint64_t cpu_rdtsc(void)
 {
+#ifdef __llir__
+    return __rdtsc();
+#else
     unsigned long l, h;
 
     __asm__ __volatile__("rdtsc" : "=a"(l), "=d"(h));
     return ((uint64_t)h << 32) | l;
+#endif
 }
 
 static inline uint64_t mul64_32(uint64_t a, uint32_t b, uint8_t s)
 {
+#ifdef __llir__
+    return (a * b) >> s;
+#else
     uint64_t prod;
 
     __asm__ (
@@ -189,46 +196,84 @@ static inline uint64_t mul64_32(uint64_t a, uint32_t b, uint8_t s)
     );
 
     return prod;
+#endif
 }
 
 /* accessing devices via port space */
 
 static inline void outb(uint16_t port, uint8_t v)
 {
+#ifdef __llir__
+    (void) port;
+    (void) v;
+    __builtin_trap();
+#else
     __asm__ __volatile__("outb %0,%1" : : "a" (v), "dN" (port));
+#endif
 }
 static inline void outw(uint16_t port, uint16_t v)
 {
+#ifdef __llir__
+    (void) port;
+    (void) v;
+    __builtin_trap();
+#else
     __asm__ __volatile__("outw %0,%1" : : "a" (v), "dN" (port));
+#endif
 }
 static inline void outl(uint16_t port, uint32_t v)
 {
+#ifdef __llir__
+    (void) port;
+    (void) v;
+    __builtin_trap();
+#else
     __asm__ __volatile__("outl %0,%1" : : "a" (v), "dN" (port));
+#endif
 }
 static inline uint8_t inb(uint16_t port)
 {
+#ifdef __llir__
+    (void) port;
+    __builtin_trap();
+#else
     uint8_t v;
 
     __asm__ __volatile__("inb %1,%0" : "=a" (v) : "dN" (port));
     return v;
+#endif
 }
 static inline uint16_t inw(uint16_t port)
 {
+#ifdef __llir__
+    (void) port;
+    __builtin_trap();
+#else
     uint16_t v;
 
     __asm__ __volatile__("inw %1,%0" : "=a" (v) : "dN" (port));
     return v;
+#endif
 }
 static inline uint32_t inl(uint16_t port)
 {
+#ifdef __llir__
+    (void) port;
+    __builtin_trap();
+#else
     uint32_t v;
 
     __asm__ __volatile__("inl %1,%0" : "=a" (v) : "dN" (port));
     return v;
+#endif
 }
 
 static inline uint64_t inq(uint16_t port_lo)
 {
+#ifdef __llir__
+    (void) port_lo;
+    __builtin_trap();
+#else
     uint16_t port_hi = port_lo + 4;
     uint32_t lo, hi;
 
@@ -236,21 +281,35 @@ static inline uint64_t inq(uint16_t port_lo)
     __asm__ __volatile__("inl %1,%0" : "=a" (hi) : "dN" (port_hi));
 
     return ((uint64_t)lo) | ((uint64_t)hi << 32);
+#endif
 }
 
 static inline void cpu_set_tls_base(uint64_t base)
 {
+#ifdef __llir__
+    (void) base;
+    __builtin_trap();
+#else
      __asm__ __volatile("wrmsr" ::
          "c" (0xc0000100), /* IA32_FS_BASE */
          "a" ((uint32_t)(base)),
          "d" ((uint32_t)(base >> 32))
      );
+#endif
 }
 
 static inline void
 x86_cpuid(uint32_t level, uint32_t *eax_out, uint32_t *ebx_out,
         uint32_t *ecx_out, uint32_t *edx_out)
 {
+#ifdef __llir__
+    (void) level;
+    (void) eax_out;
+    (void) ebx_out;
+    (void) ecx_out;
+    (void) edx_out;
+    __builtin_trap();
+#else
     uint32_t eax_, ebx_, ecx_, edx_;
 
     __asm__(
@@ -262,6 +321,7 @@ x86_cpuid(uint32_t level, uint32_t *eax_out, uint32_t *ebx_out,
     *ebx_out = ebx_;
     *ecx_out = ecx_;
     *edx_out = edx_;
+#endif
 }
 
 #endif /* !ASM_FILE */
diff --git a/configure.sh b/configure.sh
index f4f970e..fbf37a7 100755
--- a/configure.sh
+++ b/configure.sh
@@ -40,6 +40,11 @@ cc_is_clang()
     ${CC} -dM -E - </dev/null | grep -Eq '^#define __clang__ 1$'
 }
 
+cc_is_llir()
+{
+    ${CC} -dM -E - </dev/null | grep -Eq '^#define __llir__ 1$'
+}
+
 cc_has_pie()
 {
     ${CC} -dM -E - </dev/null | grep -Eq '^#define __PIE__ [1-9]$'
@@ -111,7 +116,7 @@ get_header_deps()
 config_host_linux()
 {
     # On Linux/gcc we use -nostdinc and copy all the gcc-provided headers.
-    cc_is_gcc || die "Only 'gcc' 4.x+ is supported on Linux"
+    cc_is_gcc || cc_is_llir || die "Only 'gcc' 4.x+ is supported on Linux"
     CC_INCDIR=$(${CC} -print-file-name=include)
     [ -d "${CC_INCDIR}" ] || die "Cannot determine gcc include directory"
     mkdir -p ${HOST_INCDIR}
@@ -276,15 +281,15 @@ CC_MACHINE=$(${CC} -dumpmachine)
     die "Could not run '${CC} -dumpmachine', is your compiler working?"
 # Determine HOST and ARCH based on what the toolchain reports.
 case ${CC_MACHINE} in
-    x86_64-*linux*)
+    x86_64-*linux*|llir_x86_64-*linux*)
         CONFIG_ARCH=x86_64 CONFIG_HOST=Linux
         CONFIG_GUEST_PAGE_SIZE=0x1000
         ;;
-    aarch64-*linux*)
+    aarch64-*linux*|llir_aarch64-*linux*)
         CONFIG_ARCH=aarch64 CONFIG_HOST=Linux
         CONFIG_GUEST_PAGE_SIZE=0x1000
         ;;
-    powerpc64le-*linux*|ppc64le-*linux*)
+    powerpc64le-*linux*|ppc64le-*linux*|llir_powerpc64le-*linux*)
         CONFIG_ARCH=ppc64le CONFIG_HOST=Linux
         CONFIG_GUEST_PAGE_SIZE=0x10000
         ;;
@@ -341,7 +346,7 @@ esac
 # GNU make. Given the differences in quoting rules between the two
 # (unable to sensibly use VAR="VALUE"), our convention is as follows:
 #
-# 1. GNU make parses the entire file, i.e. all variables defined below are 
+# 1. GNU make parses the entire file, i.e. all variables defined below are
 #    available to Makefiles.
 #
 # 2. Shell scripts parse the subset of *lines* starting with "CONFIG_". I.e.
diff --git a/include/solo5/hvt_abi.h b/include/solo5/hvt_abi.h
index 52111b8..5fc1a75 100644
--- a/include/solo5/hvt_abi.h
+++ b/include/solo5/hvt_abi.h
@@ -72,11 +72,17 @@ static inline void hvt_do_hypercall(int n, volatile void *arg)
 #    ifdef assert
     assert(((uint64_t)arg <= UINT32_MAX));
 #    endif
+#    ifdef __llir__
+    (void) n;
+    (void) arg;
+    __builtin_trap();
+#    else
     __asm__ __volatile__("outl %0, %1"
             :
             : "a" ((uint32_t)((uint64_t)arg)),
               "d" ((uint16_t)(HVT_HYPERCALL_PIO_BASE + n))
             : "memory");
+#    endif
 }
 #    endif
 
